# CS320-Portfolio
How can I ensure that my code, program, or software is functional and secure?
I ensure functionality by writing code strictly aligned with the requirements and verifying it through JUnit testing. In my Contact and ContactService classes, I confirmed that only valid data was accepted and that invalid data was rejected. For example, null and overlength fields resulted in no object being created. I tested both positive and negative cases to confirm stability in all situations. I also used boundary testing to verify that maximum field lengths were handled correctly. To ensure security, I validated all inputs and prevented the creation of objects with invalid states. This prevented errors, data corruption, and vulnerabilities caused by unchecked input. By combining requirement-driven development with comprehensive unit testing, I ensured that the code was both functional and secure.

How do I interpret user needs and incorporate them into a program?
I interpret user needs by breaking them down into explicit requirements and implementing features that directly enforce those requirements. For example, user needs for the Contact feature included unique IDs, valid phone numbers, and limited field lengths. I translated those needs into validation rules in the Contact class. I then wrote unit tests to confirm that the program enforced those rules at both the object and service levels. In this way, user needs became measurable constraints that guided both development and testing. By continuously aligning my code with the requirements, I ensured that the final program matched the userâ€™s expectations.

How do I approach designing software?
I approach software design with a disciplined and modular mindset. I start by separating responsibilities into classes and services. For example, the Contact class handled validation and data storage, while the ContactService class managed unique IDs, creation, modification, and deletion. This separation of concerns allowed me to test each part independently through unit testing and then confirm correct interaction through integration testing. I also adopt a defensive design approach by anticipating invalid inputs and testing them directly. By focusing on modularity, validation, and testing, I design software that is reliable, maintainable, and aligned with requirements.
